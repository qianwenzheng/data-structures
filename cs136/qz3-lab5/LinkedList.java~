/*                                                                                    
 * Name: Qianwen (Tiffany) Zheng                                                      
 * Lab: CSCI 136 (Section 05) LAB 5                                                  
 *                                                                                    
 * This class is designed to be an extension of the class DoublyLinkedList 
 * that implements lists using doubly linked elements and dummy nodes. This 
 * class makes use of two dummy nodes: one at the head of the list and one
 * at the end.                                             
 *                                                                                    
 */

/*
 * Thought Questions:
 * 
 * 1)The if statements would disappear because 
 *
 */

import structure5.Assert;
import structure5.DoublyLinkedList;
import structure5.DoublyLinkedNode;
import structure5.DoublyLinkedListIterator;
import java.util.Iterator;

public class LinkedList<E> extends DoublyLinkedList<E>
{
    /**
     * Number of elements within the list.
     */
    protected int count;
    /**
     * Reference to head of the list.
     */
    protected DoublyLinkedNode<E> head;
    /**
     * Reference to tail of the list.
     */
    protected DoublyLinkedNode<E> tail;

    /**
     * Constructs an empty list.
     *
     * @post constructs an empty list
     * 
     */
    public LinkedList()
    {
	head= new DoublyLinkedNode<E> (null);
	tail = new DoublyLinkedNode<E> (null);
	head.setNext(tail);
	tail.setPrevious(head);
	count = 0;
    }

    /**
     * Determine the number of elements in the list.
     *
     * @post returns the number of elements in list
     * 
     * @return The number of elements found in the list.
     */
    public int size()
    {
	return count; 
    }

    /**
     * Determine if the list is empty.
     *
     * @post returns true iff the list has no elements.
     * 
     * @return True iff list has no values.
     */
    public boolean isEmpty()
    {
	return size() == 0;
    }

    /**
     * Remove all values from list.
     *
     * @post removes all the elements from the list
     */
    public void clear()
    {
        head = new DoublyLinkedNode<E>(null);
	tail = new DoublyLinkedNode<E>(null);
	head.setNext(tail);
	tail.setPrevious(head);
	count = 0;
    }

    /**
     * A private routine to add an element after a node.
     * @param value the value to be added
     * @param previous the node the come before the one holding value
     * @pre previous is non null
     * @post list contains a node following previous that contains value
     */
    protected void insertAfter(E value, DoublyLinkedNode<E> previous)
    {
	DoublyLinkedNode<E> newNode = new DoublyLinkedNode<E> (value);

	if (previous == tail.previous()) {
	    tail.setPrevious(newNode);
		} 
	newNode.setNext(previous.next());
	newNode.setPrevious(previous);
	previous.setNext(newNode);
	count++;
    }

    /**
     * A private routine to remove a node.
     * @param node the node to be removed
     * @pre node is non null
     * @post node node is removed from the list
     * @return the value of the node removed
     */
    protected E remove(DoublyLinkedNode<E> node)
    {
	node.previous().setNext(node.next());
	node.next().setPrevious(node.previous());
	count--; 
	return node.value();
    }

    
    /**
     * Add a value to the head of the list.
     *
     * @pre value is not null
     * @post adds element to head of list
     * 
     * @param value The value to be added.
     */
    public void addFirst(E value)
    {
	insertAfter(value,head);
    }

    /**
     * Add a value to the tail of the list.
     *
     * @pre value is not null
     * @post adds new value to tail of list
     * 
     * @param value The value to be added.
     */
    public void addLast(E value)
    {
	System.out.println(tail.previous().value());
	insertAfter(value,tail.previous());
	
    }

    /**
     * Remove a value from the head of the list.
     * Value is returned.
     *
     * @pre list is not empty
     * @post removes first value from list
     * 
     * @return The value removed from the list.
     */
    public E removeFirst()
    {
	remove(head.next());
	return head.next().value();
    }

    /**
     * Remove a value from the tail of the list.
     *
     * @pre list is not empty
     * @post removes value from tail of list
     * 
     * @return The value removed from the list.
     */
    public E removeLast()
    {
	remove(tail.previous());
	return tail.previous().value();
    }

    /**
     * Get a copy of the first value found in the list.
     *
     * @pre list is not empty
     * @post returns first value in list.
     * 
     * @return A reference to first value in list.
     */
    public E getFirst()
    {
	return head.next().value();
    }

    /**
     * Get a copy of the last value found in the list.
     *
     * @pre list is not empty
     * @post returns last value in list.
     * 
     * @return A reference to the last value in the list.
     */
    public E getLast()
    {
	return tail.previous().value();
    }

    /**
     * Insert the value at location.
     *
     * @pre 0 <= i <= size()
     * @post adds the ith entry of the list to value o
     * @param i the index of this new value
     * @param o the the value to be stored
     */
    public void add(int i, E o)
    {
	DoublyLinkedNode<E> finger = head;
	while (i>0){
	    finger = finger.next();
	    i--;
	}
	insertAfter(o,finger);
    }

    /**
     * Remove and return the value at location i.
     *
     * @pre 0 <= i < size()
     * @post removes and returns the object found at that location.
     *
     * @param i the position of the value to be retrieved.
     * @return the value retrieved from location i (returns null if i invalid)
     */
    public E remove(int i)
    {
	DoublyLinkedNode<E> finger = head;
	if (i==0){
	    return removeFirst();
            
	} else if (i==size()-1){
	    return removeLast();
	} else {
	while (i>0){
	    finger = finger.next();
	    i--;
	}
	remove(finger);
	return finger.value();
	}
    }

    /**
     * Get the value at location i.
     *
     * @pre 0 <= i < size()
     * @post returns the object found at that location.
     *
     * @param i the position of the value to be retrieved.
     * @return the value retrieved from location i (returns null if i invalid)
     */
    public E get(int i)
    {
	DoublyLinkedNode<E> finger = head;

	if(i==size()-1){
	    getLast();
	}
	else if (i==0){
	    getFirst();
	} else {
	    
	// search for the ith element or end of list
	while (i > 0)
	{
	    finger = finger.next();
	    i--;
	}
	return finger.value();
	}
	return null;
    }

    /**
     * Set the value stored at location i to object o, returning the old value.
     *
     * @pre 0 <= i < size()
     * @post sets the ith entry of the list to value o, returns the old value.
     * @param i the location of the entry to be changed.
     * @param o the new value
     * @return the former value of the ith entry of the list.
     */
    public E set(int i, E o)
    {
	DoublyLinkedNode<E> finger = head;

	// search for the ith element or the end of the list
	while (i > 0)
	{
	    finger = finger.next();
	    i--;
	}
	// get old value, update new value
	E result = finger.value();
	finger.setValue(o);
	return result;
    }

    /**
     * Determine the first location of a value in the list.
     *
     * @pre value is not null
     * @post returns the (0-origin) index of the value,
     *   or -1 if the value is not found
     * 
     * @param value The value sought.
     * @return the index (0 is the first element) of the value, or -1
     */
    public int indexOf(E value)
    {
	int i = 0;
	DoublyLinkedNode<E> finger = head;
	
	// search for value or end of list, counting along the way
	while (!finger.value().equals(value))
	{
	    finger = finger.next();
	    i++;
	}
	// finger points to value, i is index
	if (finger == null)
	{   // value not found, return indicator
	    return -1;
	} else {
	    // value found, return index
	    return i;
	}
    }

    /**
     * Determine the last location of a value in the list.
     *
     * @pre value is not null
     * @post returns the (0-origin) index of the value,
     *   or -1 if the value is not found
     * 
     * @param value the value sought.
     * @return the index (0 is the first element) of the value, or -1
     */
    public int lastIndexOf(E value)
    {
	int i = size()-1;
	DoublyLinkedNode<E> finger = tail.previous();
	
	// search for the last matching value, result is desired index
	while (!finger.value().equals(value))
	{
	    finger = finger.previous();
	    i--;
	}
	if (finger == null)
	{   // value not found, return indicator
	    return -1;
	} else {
	    // value found, return index
	    return i;
	}
    }

    /**
     * Check to see if a value is within the list.
     *
     * @pre value not null
     * @post returns true iff value is in the list
     * 
     * @param value A value to be found in the list.
     * @return True if value is in list.
     */
    public boolean contains(E value)
    {
	return indexOf(value) != -1;
    }

    /**
     * Remove a value from the list.  At most one value is removed.
     * Any duplicates remain.  Because comparison is done with "equals,"
     * the actual value removed is returned for inspection.
     *
     * @pre value is not null.  List can be empty.
     * @post first element matching value is removed from list
     * 
     * @param value The value to be removed.
     * @return The value actually removed.
     */
    public E remove(E value)
    {
	DoublyLinkedNode<E> finger = head;
	while (!finger.value().equals(value))
	{
	    finger = finger.next();
	}
	if (finger != null){
	    remove(finger);
	    return finger.value();
	}
	return null;
    }

    /**
     * Construct an iterator to traverse the list.
     *
     * @post returns iterator that allows the traversal of list.
     * 
     * @return An iterator that traverses the list from head to tail.
     */
    public Iterator<E> iterator()
    {
	return new DoublyLinkedListIterator<E>(head,tail);
    }

    /**
     * Construct a string representation of the list.
     *
     * @post returns a string representing list
     * 
     * @return A string representing the elements of the list.
     */
    public String toString()
    {
	StringBuffer s = new StringBuffer();
	s.append("<LinkedList:");
	Iterator<E> li = iterator();
	while (li.hasNext())
	{
	    s.append(" "+li.next());
	}
	s.append(">");
	return s.toString();
    }
}


